[{"title":"08-Fanout类型的Exchange","date":"2016-03-21T14:00:14.000Z","path":"2016/03/21/2016-03-21-rabbitmq-08/","text":"1.相比严格的Direct来说就比较随意了, 只要绑定到fanout类型Exchange上的队列(bindingKey是什么并不重要), 都能收到publisher发布给这个Exchange的消息, 即使 发布消息时的routingKey 和 Exchange-Queue绑定时的bindingKey 不一致也无妨 ;代码 : public function publisher() { // 路由名称 $exchange = &apos;testRouter&apos;; // 队列名称 $queue_name1 = &apos;queue1&apos;; $queue_name2 = &apos;queue2&apos;; $queue_name3 = &apos;queue3&apos;; // 连接RabbitMQ服务 $connection = new AMQPStreamConnection(&apos;localhost&apos;, &apos;5672&apos;, &apos;guest&apos;, &apos;guest&apos;); // 创建信道 $channel = $connection-&gt;channel(); // 声明一个路由 (direct类型) $channel-&gt;exchange_declare($exchange, &apos;fanout&apos;, false, true, false); // 声明队列 (参数暂时不用了解) $channel-&gt;queue_declare($queue_name1, false, true, false, false); $channel-&gt;queue_declare($queue_name2, false, true, false, false); $channel-&gt;queue_declare($queue_name3, false, true, false, false); // 绑定路由和队列 $channel-&gt;queue_bind($queue_name1, $exchange, &apos;bindingKey1&apos;); $channel-&gt;queue_bind($queue_name2, $exchange, &apos;bindingKey1&apos;); $channel-&gt;queue_bind($queue_name3, $exchange, &apos;bindingKey1&apos;); // 创建消息 $messageBody = &apos;12345&apos;; $message = new AMQPMessage($messageBody, array(&apos;content_type&apos; =&gt; &apos;text/plain&apos;, &apos;delivery_mode&apos; =&gt; AMQPMessage::DELIVERY_MODE_PERSISTENT)); // 发布消息 // 此时即使routingKey和bindingKey不一样也无妨 // fanout类型交换机会把收到的消息发送给所有和它绑定的队列, // 而不在乎是否发送消息时的routingKey 和 交换机绑定队列时的bindingKey 是否一致 $channel-&gt;basic_publish($message, $exchange, &apos;bindingKey2&apos;); $channel-&gt;close(); $connection-&gt;close(); } 2.访问以下http://www.ls.net/publisher, 并通过rabbitmq提供的web界面可以查看确实符合上述结论","tags":[]},{"title":"07-Topic类型的Exchange","date":"2016-03-21T04:26:18.000Z","path":"2016/03/21/2016-03-21-rabbitmq-07/","text":"1.Topic类型的交换机在 消息发送到队列过程中 所使用的路由规则相比Direct类型来说稍微宽松了一点 ! 2.注意 : 正则语法是用在绑定Exchange-queue的bindingKey上, 而不是发送消息时的routingKey上 ; （这样貌似能根据.前的单词来对 消息-队列 进行分类, 某一类消息发送到以…开头bindingKey绑定的队列中） 3.测试:代码 : public function publisher() { // 路由名称 $exchange = &apos;testRouter&apos;; // 队列名称 $queue_name1 = &apos;queue1&apos;; $queue_name2 = &apos;queue2&apos;; $queue_name3 = &apos;queue3&apos;; $queue_name4 = &apos;queue4&apos;; // 连接RabbitMQ服务 $connection = new AMQPStreamConnection(&apos;localhost&apos;, &apos;5672&apos;, &apos;guest&apos;, &apos;guest&apos;); // 创建信道 $channel = $connection-&gt;channel(); // 声明一个路由 (topic类型) $channel-&gt;exchange_declare($exchange, &apos;topic&apos;, false, true, false); // 声明队列 (参数暂时不用了解) $channel-&gt;queue_declare($queue_name1, false, true, false, false); $channel-&gt;queue_declare($queue_name2, false, true, false, false); $channel-&gt;queue_declare($queue_name3, false, true, false, false); $channel-&gt;queue_declare($queue_name4, false, true, false, false); // 绑定路由和队列 $channel-&gt;queue_bind($queue_name1, $exchange, &apos;*.bindingKey&apos;); $channel-&gt;queue_bind($queue_name2, $exchange, &apos;bindingKey.*&apos;); $channel-&gt;queue_bind($queue_name3, $exchange, &apos;bindingKey&apos;); $channel-&gt;queue_bind($queue_name4, $exchange, &apos;bindingKey.#&apos;); // 创建消息 $messageBody = &apos;12345&apos;; $message = new AMQPMessage($messageBody, array(&apos;content_type&apos; =&gt; &apos;text/plain&apos;, &apos;delivery_mode&apos; =&gt; AMQPMessage::DELIVERY_MODE_PERSISTENT)); $channel-&gt;basic_publish($message, $exchange, &apos;bindingKey&apos;); $channel-&gt;close(); $connection-&gt;close(); } 效果 :","tags":[]},{"title":"06-Direct类型的Exchange","date":"2016-03-20T14:10:09.000Z","path":"2016/03/20/2016-03-20-rabbitmq-06/","text":"Direct类型的交换机在 消息发送到队列过程中 所使用的路由规则比较严格 ! 注意: 如果不创建交换机, 则RabbitMQ默认会使用一个direct类型的交换机, 并且, 发送消息的时候, 需要指定routingKey和创建queue时的queue_name一致, 因为如果不声明路由,即使用默认路由的话, RabbitMQ会把队列的queue_name作为队列和那个默认direct类型交换器绑定的bindingKey, 否则消息就不能正确放到队列中, 而丢失。 代码 : public function publisher() { // 队列名称 $queue_name = &apos;queue1&apos;; // 连接RabbitMQ服务 $connection = new AMQPStreamConnection(&apos;localhost&apos;, &apos;5672&apos;, &apos;guest&apos;, &apos;guest&apos;); // 创建信道 $channel = $connection-&gt;channel(); // 不创建Exchange // 默认会使用一个direct类型的xchange // 声明队列 $channel-&gt;queue_declare($queue_name , false, true, false, false); // 因为没有明确声明的Exchange, 所以也不需要让队列去绑定默认的交换器 // 创建消息 $messageBody = &apos;we are family&apos;; $message = new AMQPMessage($messageBody, array(&apos;content_type&apos; =&gt; &apos;text/plain&apos;, &apos;delivery_mode&apos; =&gt; AMQPMessage::DELIVERY_MODE_PERSISTENT)); // 此时, 要发送消息到创建的队列中的话, 此处的routingKey需要和队列名相同 $channel-&gt;basic_publish($message, &apos;&apos;, $queue_name); $channel-&gt;close(); $connection-&gt;close(); } 2.使用direct类型的Exchange测试 (先不为队列绑定任何消费者, 因为消费者和 routingKey,bindingKey是没一毛钱直接关系的) : 多个队列使用完全相同的bindingKey绑定同一个Exchange, 并且发送消息时的routingKey和bindingKey相同, 此时, 消息会发送到其中某个队列? 还是每个队列都会发送消息 ? (每个队列都会收到该消息, 算是广播了? ) 代码 : public function publisher() { // 路由名称 $exchange = &apos;testRouter&apos;; // 队列名称 $queue_name1 = &apos;queue1&apos;; $queue_name2 = &apos;queue2&apos;; $queue_name3 = &apos;queue3&apos;; // 连接RabbitMQ服务 $connection = new AMQPStreamConnection(&apos;localhost&apos;, &apos;5672&apos;, &apos;guest&apos;, &apos;guest&apos;); // 创建信道 $channel = $connection-&gt;channel(); // 声明一个路由 (direct类型, 也可以不用自己声明, 默认使用的也是一个direct类型的Exchange) $channel-&gt;exchange_declare($exchange, &apos;direct&apos;, false, true, false); // 声明3个队列 (参数暂时不用了解) $channel-&gt;queue_declare($queue_name1, false, true, false, false); $channel-&gt;queue_declare($queue_name2, false, true, false, false); $channel-&gt;queue_declare($queue_name3, false, true, false, false); // 绑定路由和队列 $channel-&gt;queue_bind($queue_name1, $exchange, &apos;bindingKey1&apos;); $channel-&gt;queue_bind($queue_name2, $exchange, &apos;bindingKey1&apos;); $channel-&gt;queue_bind($queue_name3, $exchange, &apos;bindingKey1&apos;); // 创建消息 $messageBody = &apos;12345&apos;; $message = new AMQPMessage($messageBody, array(&apos;content_type&apos; =&gt; &apos;text/plain&apos;, &apos;delivery_mode&apos; =&gt; AMQPMessage::DELIVERY_MODE_PERSISTENT)); // 发布消息 (这里,生产者在发布消息的时候,这个 routingKey 和 队列与交换器绑定的bindingKey必须一致 ) $channel-&gt;basic_publish($message, $exchange, &apos;bindingKey1&apos;); $channel-&gt;close(); $connection-&gt;close(); } 此时由于没有启动消费者进程, 所以消息会一直在队列中等待消费者来订阅并进行消费 ; 3.多个队列使用不完全相同的bindingKey绑定同一个Exchange, 并且发送消息时的routingKey和其中某些bindingKey相同, 此时, 消息会发送到bindingKey相同的队列? 还是每个队列都会发送消息 ? 只会发送到routingKey和bindingKey相同的队列 对于routingKey和bindingKey不同的, 队列中是不会受到消息的; 所以如果只有一个队列, 并且bindingKey和发送消息时的routingKey不一样, 那消息就彻底丢失了 代码 : public function publisher() { // 路由名称 $exchange = &apos;testRouter&apos;; // 队列名称 $queue_name1 = &apos;queue1&apos;; $queue_name2 = &apos;queue2&apos;; $queue_name3 = &apos;queue3&apos;; // 连接RabbitMQ服务 $connection = new AMQPStreamConnection(&apos;localhost&apos;, &apos;5672&apos;, &apos;guest&apos;, &apos;guest&apos;); // 创建信道 $channel = $connection-&gt;channel(); // 声明一个路由 (direct类型) $channel-&gt;exchange_declare($exchange, &apos;direct&apos;, false, true, false); // 声明队列 (参数暂时不用了解) $channel-&gt;queue_declare($queue_name1, false, true, false, false); $channel-&gt;queue_declare($queue_name2, false, true, false, false); $channel-&gt;queue_declare($queue_name3, false, true, false, false); // 绑定路由和队列 $channel-&gt;queue_bind($queue_name1, $exchange, &apos;bindingKey1&apos;); $channel-&gt;queue_bind($queue_name2, $exchange, &apos;bindingKey2&apos;); $channel-&gt;queue_bind($queue_name3, $exchange, &apos;bindingKey2&apos;); // 创建消息 $messageBody = &apos;12345&apos;; $message = new AMQPMessage($messageBody, array(&apos;content_type&apos; =&gt; &apos;text/plain&apos;, &apos;delivery_mode&apos; =&gt; AMQPMessage::DELIVERY_MODE_PERSISTENT)); // 发布消息 (这里,生产者在发布消息的时候,这个routingKey必须和后面消费者绑定的bindingKey一致 ) $channel-&gt;basic_publish($message, $exchange, &apos;bindingKey1&apos;); $channel-&gt;close(); $connection-&gt;close(); } 4.如果消息能准确地被Exchange路由到正确的队列中, 即使没有消费者订阅队列, 消息也会一直在队列中等待有消费者来订阅并消费消息 ; 5.访问以下http://www.ls.net/publisher, 并通过rabbitmq提供的web界面可以查看确实符合上述结论","tags":[]},{"title":"05-Exchange Types","date":"2016-03-20T13:30:17.000Z","path":"2016/03/20/2016-03-20-rabbitmq-05/","text":"RabbitMQ常用的Exchange Type有fanout、direct、topic、headers这四种, 不过headers类型并不太实用, 而且性能比较差, 几乎再也用不到了, 所以下面分别介绍前三种Exchange 。 1.fanout : fanout类型的Exchange路由规则非常简单, 它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中 ; 2.direct : direct类型的Exchange路由规则也很简单，它会把消息路由到那些Binding key与Routing key完全匹配的Queue中。 3.topic : 前面讲到direct类型的Exchange路由规则是完全匹配binding key与routing key，但这种严格的匹配方式在很多情况下不能满足实际业务需求。topic类型的Exchange在匹配规则上进行了扩展，它与direct类型的Exchage相似，也是将消息路由到binding key与routing key相匹配的Queue中，但这里的匹配规则有些不同，它约定： routing key为一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词），如“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit” binding key与routing key一样也是句点号“. ”分隔的字符串 binding key中可以存在两种特殊字符“”与“#”，用于做模糊匹配，其中“”用于匹配一个单词，“#”用于匹配多个单词（可以是零个）","tags":[]},{"title":"01-认识RabbitMQ","date":"2016-03-17T04:10:25.000Z","path":"2016/03/17/2016-03-17-rabbitmq-01/","text":"1.RabbitMQ是一个由Erlang开发的AMQP的开源实现: 官网是 http://www.rabbitmq.com Erlang是一种通用的面向并发的编程语言, 它由瑞典电信设备制造商爱立信所辖的CS-Lab开发, 目的是创造一种可以应对大规模并发活动的编程语言和运行环境。 AMQP(Advanced Message Queuing Protocol), 一个提供统一消息服务的应用层标准高级消息队列协议, 是应用层协议的一个开放标准, 为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。 AMQP 的出现其实也是应了广大人民群众的需求, 虽然在同步消息通讯的世界里有很多公开标准（如 COBAR的 IIOP ，或者是 SOAP 等），但是在异步消息处理中却不是这样，只有大企业有一些商业实现（如微软的 MSMQ ，IBM 的 Websphere MQ 等），因此，在 2006 年的 6 月，Cisco 、Redhat、iMatix 等联合制定了 AMQP 的公开标准。 2.RabbitMQ，或者说AMQP解决了什么问题，或者说它的应用场景是什么？ 你是否遇到过两个（多个）系统间需要通过定时任务来同步某些数据？ 你是否在为异构系统的不同进程间相互调用、通讯的问题而苦恼、挣扎？ 如果是，那么恭喜你，消息服务让你可以很轻松地解决这些问题。 消息服务擅长于解决多系统、异构系统间的数据交换（消息通知/通讯）问题，你也可以把它用于系统间服务的相互调用（RPC）。 AMDQ协议解决了以上的问题，而RabbitMQ实现了AMQP。 3.RabbitMQ的基本概念: vhost 每个virtual host本质上都是一个RabbitMQ Server，拥有它自己的queue，exchagne，和bindings rule等等, 这保证了你可以在多个不同的application中使用RabbitMQ ; RabbitMQ默认使用的是 / 这个vhost ; connect Connection 是RabbitMQ的socket链接，它封装了socket协议相关部分逻辑。 ConnectionFactory 为Connection的制造工厂。 channel Channel 是我们与RabbitMQ打交道的最重要的一个接口，我们大部分的业务操作是在Channel这个接口中完成的，包括定义Queue、定义Exchange、绑定Queue与Exchange、发布消息等。 为什么不直接通过TCP连接发送AMQP命令呢? 主要原因在对于操作系统来说建立和销毁TCP回话是非常昂贵的开销; 假设应用程序从队列消费消息, 并根据服务需求合理调度线程, 假设你进行的是TCP连接, 那么每个线程都需要自行连接到Rabbit, 而操作系统每秒建立的TCP连接数是有限的, 假设高峰期每秒有成百上千条连接, 这不仅造成TCP连接的巨大浪费, 而且操作系统没秒也就只能建立这点数量的连接。因此, 你可能很快就碰到性能瓶颈了； 如果让所有线程只使用一条TCP连接, 以满足性能方面的要求, 同时又能保证每个线程的私密性, 就像拥有独立TCP连接一样的话, 那不就非常完美了么? 这就引入了信道的概念, 线程启动后, 会在线程的连接上面创建一条信道, 也就获得了连接到Rabbit上的私密通信路径, 而不会给操作系统的TCP栈造成额外负担, 因此你可以每秒成百上千次的创建信道而不会影响操作系统, 在一条TCP连接上创建多少条信道是没有限制的, 可以把它想象成一束光纤电缆就可以 : publisher/producer producer负责创建消息, 然后发布消息到RabbitMQ服务器 exchange(交换器): 是RabbitMQ的内部对象, 用于路由消息到queue; producer创建的消息发送到RabbitMQ服务器之后, RabbitMQ服务器并不知道producer的消息需要发送给哪个queue, 所以RabbitMQ也不会直接将消息投递到某个队列中; 在RabbitMQ中, 生产者将消息投递到Queue中, 这种事情永远都不会发生; 实际的情况是，生产者将消息发送到RabbitMQ内部的Exchange, 然后由Exchange将消息路由到一个或多个Queue中; 消息被Exchange接收以后，如果没有匹配的Queue，则消息会被丢弃! RabbitMQ常用的Exchange Type有fanout、direct、topic、headers这四种, 不过headers类型并不太实用, 而且性能比较差, 几乎再也用不到了 。 queue(队列): 是RabbitMQ的内部对象, 用于存储消息 ; RabbitMQ中的消息都只能存储在Queue中，生产者生产消息并通过Exchange(交换机)最终投递到Queue中。 consumer(消费者, 订阅者): 多个消费者可以订阅同一个Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理; 4.RoutingKey, BindingKey 真实情况下, 参数名都是RoutingKey，并没有BindingKey这个参数，为了区别 生产者发送消息时 和 Exchange-Queue绑定时 的概念，我们才说RoutingKey和BindingKey; bindingKey: 在绑定（Binding）Exchange与Queue的时候，一般会指定一个RoutingKey, 为了区分下面的RoutingKey, 此时这个RoutingKey叫BindingKey; routingKey: 消费者将消息发送给Exchange时, 一般会指定一个RoutingKey, 当BindingKey与RoutingKey相匹配时，生产者发送的消息才将会被路由到对应的Queue中; 在bind多个Queue到同一个Exchange的时候，这些Binding允许使用相同的BindingKey; BindingKey并不是在所有情况下都生效，它依赖于Exchange Type，比如fanout类型的Exchange就会无视绑定时的BindingKey, 会直接将消息路由到所有绑定到该fanout-Exchange的Queues。 5.RabbitMQ中 用户和vhost之间的关系: 可以创建用户并且给用户分配vhost作用域, 用户和vhost作用域之间是多对多的分配关系 可以在连接Rabbit服务的时候指定用户和作用域, 如下 : // 主机地址, 端口, Rabbit用户, 密码, 分配给Rabbit用户的vhost域 $connection = new AMQPStreamConnection(&apos;localhost&apos;, &apos;5672&apos;, &apos;tt&apos;, &apos;tt&apos;, &apos;test&apos;);","tags":[]}]