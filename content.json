[{"title":"01-MySQL主从复制原理","date":"2017-03-15T04:20:05.000Z","path":"2017/03/15/2017-03-15-mysql-master-slave-01/","text":"1.主从复制 replication 原理 : master服务器上进行sql写语句操作的时候, 是会引起磁盘变化的 ; 所以slave服务器要想和master上的数据保持一致, 可以有两种办法 : slave按照master服务器上每次的sql写语句来执行一遍; slave按照master服务器上磁盘的变化来做一次变化 ; 2.主服务器 master 上的写操作都会被记录到 binlog 二进制日志中 ;从服务器 slave 去读主服务器的 binlog 二进制日志, 形成自己的relay中继日志中, 然后执行一遍中继日志中的操作 ; 3.所以 : 主服务器要配置binlog二进制 从服务器要配置relaylog(中继日志) 从服务器如何有权读取主服务器的binlog (binlog非常敏感, 不可能让某个用户去随便读) 所以master要授予slave账号 ; 从服务器用账号连接master ; 从服务器一声令下开启同步功能 start slave ; 4.注意: 一般会在集群中的每个sql服务器中加一个server-id来做唯一标识 ;","tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://blog.renyimin.com/tags/Mysql/"}]},{"title":"RESTful API","date":"2016-05-12T15:10:19.000Z","path":"2016/05/12/2016-05-12-restful-01/","text":"一、认识RESTful架构认识RESTful架构 二、RESTful API 设计指南1.网络应用程序,分为前端和后端两个部分。当前的发展趋势,就是前端设备层出不穷（手机、平板、桌面电脑、其他专用设备……）。因此，必须有一种统一的机制,方便不同的前端设备与后端进行通信。这导致API构架的流行，甚至出现”API First”的设计思想。 RESTful API是目前比较成熟的一套互联网应用程序的API设计理论; 2.如何设计一套合理、好用的API ? 协议: API与用户的通信协议，总是使用HTTPs协议。 域名: 应该尽量将API部署在专用域名之下, 如:https://api.example.com 如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下, 如: https://example.org/api/ 版本:（Versioning）, 应该将API的版本号放入URL, 如:https://api.example.com/v1/ 另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。 路径（Endpoint）, 路径又称”终点”（endpoint），表示API的具体网址。 在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。 举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。 https://api.example.com/v1/zoos https://api.example.com/v1/animals https://api.example.com/v1/employees HTTP动词 （对于资源的具体操作类型，由HTTP动词表示） 常用的HTTP动词有下面五个（括号里是对应的SQL命令）: GET（SELECT）：从服务器取出资源（一项或多项）。 POST（CREATE）：在服务器新建一个资源。 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。 PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。 DELETE（DELETE）：从服务器删除资源。 还有两个不常用的HTTP动词: HEAD：获取资源的元数据。 OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。 下面是一些例子: GET /zoos：列出所有动物园 POST /zoos：新建一个动物园 GET /zoos/ID：获取某个指定动物园的信息 PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息） PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息） DELETE /zoos/ID：删除某个动物园 GET /zoos/ID/animals：列出某个指定动物园的所有动物 DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物 过滤信息（Filtering）, 如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果,下面是一些常见的参数: ?limit=10：指定返回记录的数量 ?offset=10：指定返回记录的开始位置。 ?page=2&amp;per_page=100：指定第几页，以及每页的记录数。 ?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。 ?animal_type_id=1：指定筛选条件 参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。 比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。 状态码（Status Codes）, 服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务） 204 NO CONTENT - [DELETE]：用户删除数据成功。 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。 401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。 403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。 404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。 状态码的完全列表参见这里。 错误处理（Error handling）, 如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。 { error: &quot;Invalid API key&quot; } 返回结果, 针对不同操作，服务器向用户返回的结果应该符合以下规范。 GET /collection：返回资源对象的列表（数组） GET /collection/resource：返回单个资源对象 POST /collection：返回新生成的资源对象 PUT /collection/resource：返回完整的资源对象 PATCH /collection/resource：返回完整的资源对象 DELETE /collection/resource：返回一个空文档 Hypermedia API RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。 比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。 { &quot;link&quot;: { &quot;rel&quot;: &quot;collection https://www.example.com/zoos&quot;, &quot;href&quot;: &quot;https://api.example.com/zoos&quot;, &quot;title&quot;: &quot;List of zoos&quot;, &quot;type&quot;: &quot;application/vnd.yourformat+json&quot; } } 上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了; rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址）; href表示API的路径; title表示API的标题; type表示返回类型; Hypermedia API的设计被称为HATEOAS。Github的API就是这种设计，访问api.github.com会得到一个所有可用API的网址列表: { &quot;current_user_url&quot;: &quot;https://api.github.com/user&quot;, &quot;authorizations_url&quot;: &quot;https://api.github.com/authorizations&quot;, // ... } 从上面可以看到，如果想获取当前用户的信息，应该去访问api.github.com/user，然后就得到了下面结果。 { &quot;message&quot;: &quot;Requires authentication&quot;, &quot;documentation_url&quot;: &quot;https://developer.github.com/v3&quot; } 上面代码表示，服务器给出了提示信息，以及文档的网址。 其他（1）API的身份认证应该使用OAuth 2.0框架。（2）服务器返回的数据格式，应该尽量使用JSON，避免使用XML。 内容摘自阮一峰的博客","tags":[{"name":"RESTful","slug":"RESTful","permalink":"http://blog.renyimin.com/tags/RESTful/"}]},{"title":"HTTP协议","date":"2016-04-15T16:00:00.000Z","path":"2016/04/16/2017-04-16-HTTP-01/","text":"敬请期待!","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://blog.renyimin.com/tags/HTTP/"}]},{"title":"MySQL","date":"2016-04-15T16:00:00.000Z","path":"2016/04/16/2017-04-30-MySQL-01/","text":"敬请期待!","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.renyimin.com/tags/MySQL/"}]},{"title":"NGINX初探","date":"2016-04-15T16:00:00.000Z","path":"2016/04/16/2015-07-20-nginx-01/","text":"一. 百科[百科] (http://baike.baidu.com/link?url=kmtYsfJ882-y_ByHCrG61vm-GVGCltiCaMFaAyX49FeZ6RjFcT49WApZivglDhgObGI0PJGxYFni7N7to9deKq) 二. 简介1.nginx的下载: nginx的官方网站下载 : http://nginx.org/en/download.html nginx的历史版本下载 : http://nginx.org/download nginx官网提供了三个类型的版本: Mainline version：Mainline 是 Nginx 目前主力在做的版本，可以说是开发版 Stable version：最新稳定版，生产环境上建议使用的版本 Legacy versions：遗留的老版本的稳定版 ( 历史稳定版 ) 2.准备: cd /usr/local/src mkdir nginx cd /usr/local/src/nginx wget http://nginx.org/download/nginx-1.8.0.tar.gz tar -zxvf nginx-1.8.0.tar.gz 由于nginx的一些模块需要依赖第三方库, 通常有pcre库(支持rewrite模块), zlib库(支持gzip模块) 和 openssl库(支持ssl (Secure Sockets Layer 安全套接层) 模块)等 :（yum安装即可） yum -y install gcc gcc-c++ automake pcre pcre-devel zlib zlib-devel open openssl-devel 这样就完成了安装nginx服务的准备工作 ; 3.开始编译, 安装: ./configure --prefix=/usr/local/nginx (生成 Makefile 文件) make &amp;&amp; make install 目录结构: conf : 配置文件 html : 网页文件 logs : 日志文件 sbin : 主要二进制程序 启动nginx : cd /usr/local/nginx ./nginx 之后便可进行访问;","tags":[{"name":"nginx","slug":"nginx","permalink":"http://blog.renyimin.com/tags/nginx/"}]},{"title":"03-Exchange Types","date":"2016-03-18T14:10:19.000Z","path":"2016/03/18/2016-03-18-rabbitmq-04/","text":"1.RabbitMQ常用的Exchange Type有fanout、direct、topic、headers这四种(不过headers类型并不太实用,而且性能比较差,几乎再也用不到了),下面分别介绍前三种Exchange: fanout: fanout类型的Exchange路由规则非常简单, 它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中 ; direct: direct类型的Exchange路由规则也很简单，它会把消息路由到那些Binding key与Routing key完全匹配的Queue中。 topic: 前面讲到direct类型的Exchange路由规则是完全匹配binding key与routing key，但这种严格的匹配方式在很多情况下不能满足实际业务需求。topic类型的Exchange在匹配规则上进行了扩展，它与direct类型的Exchage相似，也是将消息路由到binding key与routing key相匹配的Queue中，但这里的匹配规则有些不同，它约定： routing key为一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词），如“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit” binding key与routing key一样也是句点号“. ”分隔的字符串 binding key中可以存在两种特殊字符“”与“#”，用于做模糊匹配，其中“”用于匹配一个单词，“#”用于匹配多个单词（可以是零个） Direct类型的Exchange :1.Direct类型的交换机在 消息发送到队列过程中 所使用的路由规则比较严格 ! 注意: 如果不创建交换机, 则RabbitMQ默认会使用一个direct类型的交换机, 并且, 发送消息的时候, 需要指定routingKey和创建queue时的queue_name一致, 因为如果不声明路由,即使用默认路由的话, RabbitMQ会把队列的queue_name作为队列和那个默认direct类型交换器绑定的bindingKey, 否则消息就不能正确路由到队列中而丢失。 代码: 12345678910111213141516171819202122232425262728public function publisher()&#123; // 队列名称 $queue_name = 'queue1'; // 连接RabbitMQ服务 $connection = new AMQPStreamConnection('localhost', '5672', 'guest', 'guest'); // 创建信道 $channel = $connection-&gt;channel(); // 不创建Exchange // 默认会使用一个direct类型的xchange // 声明队列 $channel-&gt;queue_declare($queue_name , false, true, false, false); // 因为没有明确声明的Exchange, 所以也不需要让队列去绑定默认的交换器 // 创建消息 $messageBody = 'we are family'; $message = new AMQPMessage($messageBody, array('content_type' =&gt; 'text/plain', 'delivery_mode' =&gt; AMQPMessage::DELIVERY_MODE_PERSISTENT)); // 此时, 要发送消息到创建的队列中的话, 此处的routingKey需要和队列名相同 $channel-&gt;basic_publish($message, '', $queue_name); $channel-&gt;close(); $connection-&gt;close();&#125; 2.使用direct类型的Exchange测试 : 多个队列使用完全相同的bindingKey绑定同一个Exchange, 并且发送消息时的routingKey和bindingKey相同, 此时, 消息会发送到其中某个队列? 还是每个队列都会发送消息 ? 每个队列都会收到该消息 代码 : 12345678910111213141516171819202122232425262728293031323334353637public function publisher()&#123; // 路由名称 $exchange = 'testRouter'; // 队列名称 $queue_name1 = 'queue1'; $queue_name2 = 'queue2'; $queue_name3 = 'queue3'; // 连接RabbitMQ服务 $connection = new AMQPStreamConnection('localhost', '5672', 'guest', 'guest'); // 创建信道 $channel = $connection-&gt;channel(); // 声明一个路由 (direct类型, 也可以不用自己声明, 默认使用的也是一个direct类型的Exchange) $channel-&gt;exchange_declare($exchange, 'direct', false, true, false); // 声明3个队列 (参数暂时不用了解) $channel-&gt;queue_declare($queue_name1, false, true, false, false); $channel-&gt;queue_declare($queue_name2, false, true, false, false); $channel-&gt;queue_declare($queue_name3, false, true, false, false); // 绑定路由和队列 $channel-&gt;queue_bind($queue_name1, $exchange, 'bindingKey1'); $channel-&gt;queue_bind($queue_name2, $exchange, 'bindingKey1'); $channel-&gt;queue_bind($queue_name3, $exchange, 'bindingKey1'); // 创建消息 $messageBody = '12345'; $message = new AMQPMessage($messageBody, array('content_type' =&gt; 'text/plain', 'delivery_mode' =&gt; AMQPMessage::DELIVERY_MODE_PERSISTENT)); // 发布消息 (这里,生产者在发布消息的时候,这个 routingKey 和 队列与交换器绑定的bindingKey必须一致 ) $channel-&gt;basic_publish($message, $exchange, 'bindingKey1'); $channel-&gt;close(); $connection-&gt;close();&#125; 此时由于没有启动消费者进程, 所以消息会一直在队列中等待消费者来订阅并进行消费 ; 3.多个队列使用不完全相同的bindingKey绑定同一个Exchange, 并且发送消息时的routingKey和其中某些bindingKey相同, 此时: 只会发送到routingKey和bindingKey相同的队列 对于routingKey和bindingKey不同的, 队列中是不会收到消息的; 所以如果只有一个队列, 并且bindingKey和发送消息时的routingKey不一样, 那消息就彻底丢失了 代码 : 1234567891011121314151617181920212223242526272829303132333435public function publisher()&#123; // 路由名称 $exchange = 'testRouter'; // 队列名称 $queue_name1 = 'queue1'; $queue_name2 = 'queue2'; $queue_name3 = 'queue3'; // 连接RabbitMQ服务 $connection = new AMQPStreamConnection('localhost', '5672', 'guest', 'guest'); // 创建信道 $channel = $connection-&gt;channel(); // 声明一个路由 (direct类型) $channel-&gt;exchange_declare($exchange, 'direct', false, true, false); // 声明队列 (参数暂时不用了解) $channel-&gt;queue_declare($queue_name1, false, true, false, false); $channel-&gt;queue_declare($queue_name2, false, true, false, false); $channel-&gt;queue_declare($queue_name3, false, true, false, false); // 绑定路由和队列 $channel-&gt;queue_bind($queue_name1, $exchange, 'bindingKey1'); $channel-&gt;queue_bind($queue_name2, $exchange, 'bindingKey2'); $channel-&gt;queue_bind($queue_name3, $exchange, 'bindingKey2'); // 创建消息 $messageBody = '12345'; $message = new AMQPMessage($messageBody, array('content_type' =&gt; 'text/plain', 'delivery_mode' =&gt; AMQPMessage::DELIVERY_MODE_PERSISTENT)); // 发布消息 (这里,生产者在发布消息的时候,这个routingKey必须和后面消费者绑定的bindingKey一致 ) $channel-&gt;basic_publish($message, $exchange, 'bindingKey1'); $channel-&gt;close(); $connection-&gt;close();&#125; 如果消息能准确地被Exchange路由到正确的队列中, 即使没有消费者订阅队列, 消息也会一直在队列中等待有消费者来订阅并消费消息 ; Topic类型的Exchange :1.Topic类型的交换机在 消息发送到队列过程中 所使用的路由规则相比Direct类型来说稍微宽松了一点 ! 2.注意: 正则语法是用在绑定Exchange-queue的bindingKey上,而不是发送消息时的routingKey上 ; 3.测试: 代码 : 12345678910111213141516171819202122232425262728293031323334353637public function publisher()&#123; // 路由名称 $exchange = 'testRouter'; // 队列名称 $queue_name1 = 'queue1'; $queue_name2 = 'queue2'; $queue_name3 = 'queue3'; $queue_name4 = 'queue4'; // 连接RabbitMQ服务 $connection = new AMQPStreamConnection('localhost', '5672', 'guest', 'guest'); // 创建信道 $channel = $connection-&gt;channel(); // 声明一个路由 (topic类型) $channel-&gt;exchange_declare($exchange, 'topic', false, true, false); // 声明队列 (参数暂时不用了解) $channel-&gt;queue_declare($queue_name1, false, true, false, false); $channel-&gt;queue_declare($queue_name2, false, true, false, false); $channel-&gt;queue_declare($queue_name3, false, true, false, false); $channel-&gt;queue_declare($queue_name4, false, true, false, false); // 绑定路由和队列 $channel-&gt;queue_bind($queue_name1, $exchange, '*.bindingKey'); $channel-&gt;queue_bind($queue_name2, $exchange, 'bindingKey.*'); $channel-&gt;queue_bind($queue_name3, $exchange, 'bindingKey'); $channel-&gt;queue_bind($queue_name4, $exchange, 'bindingKey.#'); // 创建消息 $messageBody = '12345'; $message = new AMQPMessage($messageBody, array('content_type' =&gt; 'text/plain', 'delivery_mode' =&gt; AMQPMessage::DELIVERY_MODE_PERSISTENT)); $channel-&gt;basic_publish($message, $exchange, 'bindingKey'); $channel-&gt;close(); $connection-&gt;close();&#125; 效果 : Fanout类型的Exchange :1.相比严格的Direct来说就比较随意了, 只要绑定到fanout类型Exchange上的队列(bindingKey是什么并不重要), 都能收到publisher发布给这个Exchange的消息, 即使 发布消息时的routingKey 和 Exchange-Queue绑定时的bindingKey 不一致也无妨 ; 代码 : 1234567891011121314151617181920212223242526272829303132333435363738public function publisher()&#123; // 路由名称 $exchange = 'testRouter'; // 队列名称 $queue_name1 = 'queue1'; $queue_name2 = 'queue2'; $queue_name3 = 'queue3'; // 连接RabbitMQ服务 $connection = new AMQPStreamConnection('localhost', '5672', 'guest', 'guest'); // 创建信道 $channel = $connection-&gt;channel(); // 声明一个路由 (direct类型) $channel-&gt;exchange_declare($exchange, 'fanout', false, true, false); // 声明队列 (参数暂时不用了解) $channel-&gt;queue_declare($queue_name1, false, true, false, false); $channel-&gt;queue_declare($queue_name2, false, true, false, false); $channel-&gt;queue_declare($queue_name3, false, true, false, false); // 绑定路由和队列 $channel-&gt;queue_bind($queue_name1, $exchange, 'bindingKey1'); $channel-&gt;queue_bind($queue_name2, $exchange, 'bindingKey1'); $channel-&gt;queue_bind($queue_name3, $exchange, 'bindingKey1'); // 创建消息 $messageBody = '12345'; $message = new AMQPMessage($messageBody, array('content_type' =&gt; 'text/plain', 'delivery_mode' =&gt; AMQPMessage::DELIVERY_MODE_PERSISTENT)); // 发布消息 // 此时即使routingKey和bindingKey不一样也无妨 // fanout类型交换机会把收到的消息发送给所有和它绑定的队列, // 而不在乎是否发送消息时的routingKey 和 交换机绑定队列时的bindingKey 是否一致 $channel-&gt;basic_publish($message, $exchange, 'bindingKey2'); $channel-&gt;close(); $connection-&gt;close();&#125; 访问以下http://www.ls.net/publisher (我本地的生产者), 并通过rabbitmq提供的web界面进行测试","tags":[{"name":"rabbitmq","slug":"rabbitmq","permalink":"http://blog.renyimin.com/tags/rabbitmq/"},{"name":"php","slug":"php","permalink":"http://blog.renyimin.com/tags/php/"}]},{"title":"03-rabbitmq几个特点","date":"2016-03-18T04:40:14.000Z","path":"2016/03/18/2016-03-18-rabbitmq-03/","text":"持久化1.RabbitMQ 默认是非持久 队列 、 Exchange 、 消息 的,这意味着一旦消息服务器重启, 所有已声明的队列, Exchange 以及队列中的消息都会丢失。 通过设置Exchange和MessageQueue的durable属性为true,可以使得队列和Exchange持久化; 但是这还不能使得队列中的消息持久化,这需要生产者在发送消息的时候,将delivery mode设置为2,只有这3个全部设置完成后,才能保证服务器重启不会对现有的队列造成影响。 这里需要注意的是, 只有 durable为true的Exchange 和 durable为ture的Queues 才能绑定, 否则在绑定时, RabbitMQ都会抛错的。 持久化会对RabbitMQ的性能造成比较大的影响, 可能会下降10倍不止。 事务机制 VS Publisher Confirm","tags":[{"name":"rabbitmq","slug":"rabbitmq","permalink":"http://blog.renyimin.com/tags/rabbitmq/"},{"name":"php","slug":"php","permalink":"http://blog.renyimin.com/tags/php/"}]},{"title":"02-RabbitMQ基本架构","date":"2016-03-17T13:30:25.000Z","path":"2016/03/17/2016-03-17-rabbitmq-02/","text":"摘自网络的一张简单原理图 : 上图中的ClientA,B 其实就是上篇文章中提到的publisher(producer)生产者 上图中的Client1,2,3 consumer 消费者 Exchange1,2和Queue1,2 都是在RabbitMQ服务内部的 RoutingKey和BindingKey也进行了区分","tags":[{"name":"rabbitmq","slug":"rabbitmq","permalink":"http://blog.renyimin.com/tags/rabbitmq/"},{"name":"php","slug":"php","permalink":"http://blog.renyimin.com/tags/php/"}]},{"title":"01-认识RabbitMQ","date":"2016-03-17T04:10:25.000Z","path":"2016/03/17/2016-03-17-rabbitmq-01/","text":"1.RabbitMQ是一个由Erlang开发的AMQP的开源实现: 官网是 http://www.rabbitmq.com Erlang是一种通用的面向并发的编程语言, 它由瑞典电信设备制造商爱立信所辖的CS-Lab开发, 目的是创造一种可以应对大规模并发活动的编程语言和运行环境。 AMQP(Advanced Message Queuing Protocol), 一个提供统一消息服务的应用层标准高级消息队列协议, 是应用层协议的一个开放标准, 为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。 AMQP 的出现其实也是应了广大人民群众的需求, 虽然在同步消息通讯的世界里有很多公开标准（如 COBAR的 IIOP ，或者是 SOAP 等），但是在异步消息处理中却不是这样，只有大企业有一些商业实现（如微软的 MSMQ ，IBM 的 Websphere MQ 等），因此，在 2006 年的 6 月，Cisco 、Redhat、iMatix 等联合制定了 AMQP 的公开标准。 2.RabbitMQ，或者说AMQP解决了什么问题，或者说它的应用场景是什么？ 你是否遇到过两个（多个）系统间需要通过定时任务来同步某些数据？ 你是否在为异构系统的不同进程间相互调用、通讯的问题而苦恼、挣扎？ 如果是，那么恭喜你，消息服务让你可以很轻松地解决这些问题。 消息服务擅长于解决多系统、异构系统间的数据交换（消息通知/通讯）问题，你也可以把它用于系统间服务的相互调用（RPC）。 AMDQ协议解决了以上的问题，而RabbitMQ实现了AMQP。 3.RabbitMQ的基本概念: vhost 每个virtual host本质上都是一个RabbitMQ Server，拥有它自己的queue，exchagne，和bindings rule等等, 这保证了你可以在多个不同的application中使用RabbitMQ ; RabbitMQ默认使用的是 / 这个vhost ; connect Connection 是RabbitMQ的socket链接，它封装了socket协议相关部分逻辑。 ConnectionFactory 为Connection的制造工厂。 channel Channel 是我们与RabbitMQ打交道的最重要的一个接口，我们大部分的业务操作是在Channel这个接口中完成的，包括定义Queue、定义Exchange、绑定Queue与Exchange、发布消息等。 为什么不直接通过TCP连接发送AMQP命令呢? 主要原因在对于操作系统来说建立和销毁TCP回话是非常昂贵的开销; 假设应用程序从队列消费消息, 并根据服务需求合理调度线程, 假设你进行的是TCP连接, 那么每个线程都需要自行连接到Rabbit, 而操作系统每秒建立的TCP连接数是有限的, 假设高峰期每秒有成百上千条连接, 这不仅造成TCP连接的巨大浪费, 而且操作系统没秒也就只能建立这点数量的连接。因此, 你可能很快就碰到性能瓶颈了； 如果让所有线程只使用一条TCP连接, 以满足性能方面的要求, 同时又能保证每个线程的私密性, 就像拥有独立TCP连接一样的话, 那不就非常完美了么? 这就引入了信道的概念, 线程启动后, 会在线程的连接上面创建一条信道, 也就获得了连接到Rabbit上的私密通信路径, 而不会给操作系统的TCP栈造成额外负担, 因此你可以每秒成百上千次的创建信道而不会影响操作系统, 在一条TCP连接上创建多少条信道是没有限制的, 可以把它想象成一束光纤电缆就可以 : publisher/producer producer负责创建消息, 然后发布消息到RabbitMQ服务器 exchange(交换器): 是RabbitMQ的内部对象, 用于路由消息到queue; producer创建的消息发送到RabbitMQ服务器之后, RabbitMQ服务器并不知道producer的消息需要发送给哪个queue, 所以RabbitMQ也不会直接将消息投递到某个队列中; 在RabbitMQ中, 生产者将消息投递到Queue中, 这种事情永远都不会发生; 实际的情况是，生产者将消息发送到RabbitMQ内部的Exchange, 然后由Exchange将消息路由到一个或多个与其通过bindingKey绑定的Queue中; 消息被Exchange接收以后，如果没有匹配的Queue，则消息会被丢弃! RabbitMQ常用的Exchange Type有fanout、direct、topic、headers这四种, 不过headers类型并不太实用, 而且性能比较差, 几乎再也用不到了 。 queue(队列): 是RabbitMQ的内部对象, 用于存储消息 ; RabbitMQ中的消息都只能存储在Queue中，生产者生产消息并通过Exchange(交换机)最终投递到Queue中。 注意: 同一个vhost下,声明同名队列, 但是参数不同, 会出现什么情况? 会报错! consumer(消费者, 订阅者): 多个消费者可以订阅同一个Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理; Message acknowledgment(消息确认 ack) 在实际应用中,可能会发生消费者收到Queue中的消息,但没有处理完成就宕机（或出现其他意外）的情况,这种情况下就可能会导致消息丢失。 为了避免这种情况发生,我们可以要求消费者在消费完消息后发送一个回执给RabbitMQ,RabbitMQ收到消息回执（Message acknowledgment）后才将该消息从Queue中移除;如果RabbitMQ没有收到回执并检测到消费者的RabbitMQ连接断开,则RabbitMQ会将该消息发送给其他消费者（如果存在多个消费者）进行处理。这里不存在timeout概念,一个消费者处理消息时间再长也不会导致该消息被发送给其他消费者。 这里会产生另外一个问题,如果我们的开发人员在处理完业务逻辑后,忘记发送回执给RabbitMQ,这将会导致严重的bug——Queue中堆积的消息会越来越多; 虽然消费者重启后会重复消费这些消息并重复执行业务逻辑。 消息拒绝 reject 既然RabbitMQ提供了ACK某一个消息的命令,当然也提供了Reject某一个消息的命令。 当客户端发生错误,调用basic.reject命令拒绝某一个消息时,可以设置一个requeue的属性: 如果为true,则消息服务器会重传该消息给下一个订阅者; 如果为false,则会直接删除该消息; 当然,也可以通过ack,让消息服务器直接删除该消息并且不会重传。 4.RoutingKey, BindingKey 真实情况下, 参数名都是RoutingKey，并没有BindingKey这个参数，为了区别 生产者发送消息时 和 Exchange-Queue绑定时 的概念，我们才说RoutingKey和BindingKey; bindingKey: 在绑定（Binding）Exchange与Queue的时候，一般会指定一个RoutingKey, 为了区分下面的RoutingKey, 此时这个RoutingKey叫BindingKey; routingKey: 消费者将消息发送给Exchange时, 一般会指定一个RoutingKey, 当BindingKey与RoutingKey相匹配时，生产者发送的消息才将会被路由到对应的Queue中; 在bind多个Queue到同一个Exchange的时候，这些Binding允许使用相同的BindingKey; BindingKey并不是在所有情况下都生效，它依赖于Exchange Type，比如fanout类型的Exchange就会无视绑定时的BindingKey, 会直接将消息路由到所有绑定到该fanout-Exchange的Queues。 5.RabbitMQ中 用户和vhost之间的关系: 可以创建用户并且给用户分配vhost作用域, 用户和vhost作用域之间是多对多的分配关系 可以在连接Rabbit服务的时候指定用户和作用域, 如下 : // 主机地址, 端口, Rabbit用户, 密码, 分配给Rabbit用户的vhost域 $connection = new AMQPStreamConnection(&apos;localhost&apos;, &apos;5672&apos;, &apos;tt&apos;, &apos;tt&apos;, &apos;test&apos;);","tags":[{"name":"rabbitmq","slug":"rabbitmq","permalink":"http://blog.renyimin.com/tags/rabbitmq/"},{"name":"php","slug":"php","permalink":"http://blog.renyimin.com/tags/php/"}]},{"title":"NGINX信号控制","date":"2015-07-21T16:00:00.000Z","path":"2015/07/22/2015-07-22-nginx-02/","text":"一. 控制nginx服务的启停有不止一种方法,下面先使用 nginx服务的信号控制1.上节已经编译安装了Nginx, 并且顺利启动 , 那如果要停止/重启Nginx怎么办 ? nginx的开启: ./nginx 那重启和关闭现在就可以先使用下面的 nginx信号量 ! 2.nginx 的信号控制, 向Nginx主进程发送信号有两种方法 : 一种是使用Nginx二进制文件, 以后再讲 ; 另一种方法是使用kill命令发送信号, 用法是: kill -SIGNAL PID 二.kill命令发送信号:1.INT / TERM 查看nginx服务进程 : ps aux | grep nginx nginx有一个主进程文件,它不直接响应浏览器请求,而是用来管理子进程; 当有浏览器进行请求的时候,由子进程负责响应, 主进程负责控制子进程; 所以可以看到nginx服务有master process主进程, 也有worker process 这个干活的进程 ! 对nginx进程施加影响: kill -INT/TERM 3321(主进程号) 注意: Term或INT, 轻易不用, 它俩都会直接关闭进程; 2.QUIT 平滑重启nginx 3.HUP 平滑读取新配置文件, 并开启新进程, 然后优雅地关闭旧进程 在修改完nginx的配置文件之后是需要重启生效的, 此处可以使用 kill -HUP nginx主进程号 4.USR1 信号 : kill -USR1 主进程号 重新打开日志文件, 可用于日志切割 在把自定义日志文件重新删除之后, 重新创建一个新的自定义服务日志文件的话, 即使名字完全一样, 我们发现这个新的自定义服务日志文件并不会进行用户访问信息的记录, 除非重启nginx服务; 其实这个时候就需要用到USR1信号量了, 对于新建的同名日志文件(可能文件的id并不同, 所以需要nginx平缓重新确定一下日志文件) : 切割nginx日志脚本(日志部分探讨) : 5.USR2 信号 和 WHICH 信号配合起来使用(以后探讨) ; 三.nginx也提供了一些命令操作 -v : 打印版本号并退出 -V : 打印版本号和配置并退出 -t : 测试配置正确性并退出, (在配置正确的时候, 也会进行如下提示, 而-qt只在配置出错的情况下有提示) ( 有时候还会配合-c参数, 用来指定配置文件的路径；当然, 默认情况下会使用nginx安装目录下的conf/nginx.conf,所以-c参数也不多使用) -q : 测试配置时只显示错误, 所以 -q 和 -t 一起连用的时候, 如果配置文件无错误的话, 将不会输出上面-t时的内容 : -s signal : 用来向nginx服务的主进程发送信号: ./nginx -s stop – 对应的信号量的 kill -INT PID./nginx -s quit – 百度: 完整有序的停止nginx 对应信号量的 kill -QUIT PID./nginx -s reload ( 明显是重读配置文件 ) – 对应的信号量的 kill -HUP PID./nginx -s reopen – 重新打开日志文件 对应信号量 kill -USR1 PID","tags":[{"name":"nginx","slug":"nginx","permalink":"http://blog.renyimin.com/tags/nginx/"}]}]