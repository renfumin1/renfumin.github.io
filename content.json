[{"title":"01-认识RabbitMQ","date":"2016-03-17T04:10:25.000Z","path":"2016/03/17/2016-03-17-rabbitmq-01/","text":"1.RabbitMQ是一个由Erlang开发的AMQP的开源实现: 官网是 http://www.rabbitmq.com Erlang是一种通用的面向并发的编程语言, 它由瑞典电信设备制造商爱立信所辖的CS-Lab开发, 目的是创造一种可以应对大规模并发活动的编程语言和运行环境。 AMQP(Advanced Message Queuing Protocol), 一个提供统一消息服务的应用层标准高级消息队列协议, 是应用层协议的一个开放标准, 为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。 AMQP 的出现其实也是应了广大人民群众的需求, 虽然在同步消息通讯的世界里有很多公开标准（如 COBAR的 IIOP ，或者是 SOAP 等），但是在异步消息处理中却不是这样，只有大企业有一些商业实现（如微软的 MSMQ ，IBM 的 Websphere MQ 等），因此，在 2006 年的 6 月，Cisco 、Redhat、iMatix 等联合制定了 AMQP 的公开标准。 2.RabbitMQ，或者说AMQP解决了什么问题，或者说它的应用场景是什么？ 你是否遇到过两个（多个）系统间需要通过定时任务来同步某些数据？ 你是否在为异构系统的不同进程间相互调用、通讯的问题而苦恼、挣扎？ 如果是，那么恭喜你，消息服务让你可以很轻松地解决这些问题。 消息服务擅长于解决多系统、异构系统间的数据交换（消息通知/通讯）问题，你也可以把它用于系统间服务的相互调用（RPC）。 AMDQ协议解决了以上的问题，而RabbitMQ实现了AMQP。 3.RabbitMQ的基本概念: vhost 每个virtual host本质上都是一个RabbitMQ Server，拥有它自己的queue，exchagne，和bindings rule等等, 这保证了你可以在多个不同的application中使用RabbitMQ ; RabbitMQ默认使用的是 / 这个vhost ; connect Connection 是RabbitMQ的socket链接，它封装了socket协议相关部分逻辑。 ConnectionFactory 为Connection的制造工厂。 channel Channel 是我们与RabbitMQ打交道的最重要的一个接口，我们大部分的业务操作是在Channel这个接口中完成的，包括定义Queue、定义Exchange、绑定Queue与Exchange、发布消息等。 为什么不直接通过TCP连接发送AMQP命令呢? 主要原因在对于操作系统来说建立和销毁TCP回话是非常昂贵的开销; 假设应用程序从队列消费消息, 并根据服务需求合理调度线程, 假设你进行的是TCP连接, 那么每个线程都需要自行连接到Rabbit, 而操作系统每秒建立的TCP连接数是有限的, 假设高峰期每秒有成百上千条连接, 这不仅造成TCP连接的巨大浪费, 而且操作系统没秒也就只能建立这点数量的连接。因此, 你可能很快就碰到性能瓶颈了； 如果让所有线程只使用一条TCP连接, 以满足性能方面的要求, 同时又能保证每个线程的私密性, 就像拥有独立TCP连接一样的话, 那不就非常完美了么? 这就引入了信道的概念, 线程启动后, 会在线程的连接上面创建一条信道, 也就获得了连接到Rabbit上的私密通信路径, 而不会给操作系统的TCP栈造成额外负担, 因此你可以每秒成百上千次的创建信道而不会影响操作系统, 在一条TCP连接上创建多少条信道是没有限制的, 可以把它想象成一束光纤电缆就可以 : publisher/producer producer负责创建消息, 然后发布消息到RabbitMQ服务器 exchange(交换器): 是RabbitMQ的内部对象, 用于路由消息到queue; producer创建的消息发送到RabbitMQ服务器之后, RabbitMQ服务器并不知道producer的消息需要发送给哪个queue, 所以RabbitMQ也不会直接将消息投递到某个队列中; 在RabbitMQ中, 生产者将消息投递到Queue中, 这种事情永远都不会发生; 实际的情况是，生产者将消息发送到RabbitMQ内部的Exchange, 然后由Exchange将消息路由到一个或多个Queue中; 消息被Exchange接收以后，如果没有匹配的Queue，则消息会被丢弃! RabbitMQ常用的Exchange Type有fanout、direct、topic、headers这四种, 不过headers类型并不太实用, 而且性能比较差, 几乎再也用不到了 。 queue(队列): 是RabbitMQ的内部对象, 用于存储消息 ; RabbitMQ中的消息都只能存储在Queue中，生产者生产消息并通过Exchange(交换机)最终投递到Queue中。 consumer(消费者, 订阅者): 多个消费者可以订阅同一个Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理; 4.RabbitMQ中 用户和vhost之间的关系 : 可以创建用户并且给用户分配vhost作用域, 用户和vhost作用域之间是多对多的分配关系 可以在连接Rabbit服务的时候指定用户和作用域, 如下 : // 主机地址, 端口, Rabbit用户, 密码, 分配给Rabbit用户的vhost域 $connection = new AMQPStreamConnection(&apos;localhost&apos;, &apos;5672&apos;, &apos;tt&apos;, &apos;tt&apos;, &apos;test&apos;);","tags":[]}]